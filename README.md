# docker_django_dev_env
### Проект-шаблон с набор контейнеров для быстрого развертывания окружения разработчика, использующегося для разработки, отладки и запуска Django-проекта. Контейнеры: Postgresql, Redis, Django, Celery. 

### Идея проекта: чтобы не таскать из проекта в проект, сохранить в репозитории docker-compose конфиг со всем необходимым, c которым может работать почти любой джанго-проект (с минимально необходимой настройкой: установка необходимых пакетов, настройка отладчика в джанго-проекте, заведение переменных окружения в .env).

## Требования:
- Linux-based OS (тестировалось на Ubuntu 22.04.4), MacOS, WSL.
- Установленный docker и docker compose.

## Описание:
### Это окружение разработчика и задумывалось только для запуска на машине разработчика, не для деплоя на бою! 
Развернутый набор контейнеров позволит:
- Редактировать файлы джанго проекта на хосте и изменения будут сразу применены в контейнере, без необходимости пересборки (код проекта примонтирован в контейнер через bind mount). Пользователь на хосте и в контейнере имеют одинаковое имя и uid, что позволяет избежать конфликта с правами на файлы при сохранении кода.
- Отладка кода, запущенного в контейнере, в VS Code (используется пакет debugpy и конфиг VS Code для дебага).
- В docker compose конфиге настроена очередность запуска контейнеров и необходимые healthchecks.

## Настройка:
1. Создать корневую папку с именем вашего джанго-проекта и зайти в нее. Внутри папки склонить проект с окружением разработчика и зайти в папку **docker_django_dev_env**.
```bash
mkdir name_your_django_project  
cd name_your_django_project  
git clone https://github.com/weirdoomer/docker_django_dev_env.git
cd docker_django_dev_env
```
2. В папку **docker_django_dev_env** склонить ваш джанго-проект, добавив его в папку **app**, выполнив команду:
```bash
git clone your_repository_link ./app
```
- В папке **app** (в которую ранее склонировали ваш джанго-проект) должен быть файл requirements.txt (создать, если в вашем проекте ранее его не было) и следующие пакеты, необходимые для того, чтобы окружение разработчика работало правильно: **Django, "psycopg[binary]", debugpy**, **redis**, **django-redis**, **celery**

- В папке **docker_django_dev_env** для правильной работы контейнеров должен быть файл **.env** со следующими переменными окружения, необходимыми для сборки контейнеров и работы джанго-проекта. Вместо **paste_your_variable_value** вставьте ваши значения из **settings.py**.

**P.S**: Файл **.env** используется совместно docker-compose (переменные для postgres) и джанго-проектом (все переменные в файле). Если в вашем джанго-проекте ранее вы не выносили переменные окружения в файл, советую использовать os.environ или любое подобное решение. Это хорошая практика, влияющая на безопасность проекта. 
```bash
DEBUG=True
SECRET_KEY=paste_your_variable_value
ALLOWED_HOSTS=localhost 127.0.0.1
POSTGRES_ENGINE=django.db.backends.postgresql
POSTGRES_DB=paste_your_variable_value
POSTGRES_USER=paste_your_variable_value
POSTGRES_PASSWORD=paste_your_variable_value
POSTGRES_HOST=db
POSTGRES_PORT=5432
```
3. Для настройки отладки в контейнере через debugpy, добавьте в файл **manage.py** следующее:
```python
from django.conf import settings


    if settings.DEBUG:
        if os.environ.get('RUN_MAIN'):
            import debugpy
            debugpy.listen(('0.0.0.0', 3000))
            print('debugpy attached!')
```


## Использование и разработка:
-  Докер-команды для работы:
    - сборка образов с джангой и celery на основе Dockerfile и передачей нужных аргументов:
    ```bash
    docker compose build --build-arg USER=$USER --build-arg UID=$UID
    ```
    - сборка образов оставшихся сервисов и запуск контейнеров (флаг -d освобождает терминал и выполняет команду в бэкграунде):
    ```bash
    docker compose up -d
    ```
    - остановка всех запущенных сервисов:
    ```bash
    docker compose stop
    ```
    - запуск остановленных сервисов:
    ```bash
    docker compose start
    ```
    - остановка и удаление всех контейнеров сервисов (флаг -v удаляет volumes, привязанные к сервисам)
    ```bash
    docker compose down -v
    ```
    - удаление всех остановленных контейнеров, всех сетей, не использующихся ни одним контейнером, всех образов, не использующихся ни одним контейнером, весь билд-кэш:
    ```bash
    docker system prune -a
    ```

- В шаблоне есть файл с vs code workspace (.vscode/project.code-workspace) и дебаг-конфиг (.vscode/launch.json). Для открытия проекта в vs code, открыть файл **project.code-workspace**.
- Папка **docker_django_dev_env** содержит гит-репу шаблона (папка .git), папка **app** будет содержать свою гит-репу джанго-проекта - они не связаны друг с другом. Чтобы обновить файлы проекта с шаблоном нужно сделать **git pull** в папке **docker_django_dev_env**. Это не отразится на файлах джанго проекта, которые расположены в папке **app** (ибо папка app в .gitignore).
Если обновление проекта с шаблоном не предвидится, можно вообще удалить .git папку из **docker_django_dev_env**.
- При изменении файлов джанго-проекта на хосте, runserver внутри контейнера перезапустит сервер (на 16.08.24 пока используется не gunicorn, а джанговский runserver).
- Для отладки кода джанго-проекта, поставить точки останова в коде, затем в vs code нажать на иконку **Run and Debug** на правой панели и нажать на зеленую кнопку play (конфигурация отладки будет называться **Python Debugging: Remote Attach**)
- **Django shell** должен использоваться внутри контейнера с сервером, а не на хосте, чтобы не сломалась Django ORM (ибо бд также развернута в контейнере, а не на хосте). Для использования джанго-шелла выполнить:
```bash
docker compose exec web python manage.py shell
```
- Создание и применение миграций, также как и любые другие **manage.py** команды должны также использоваться в контейнере сервера через **docker compose exec**.